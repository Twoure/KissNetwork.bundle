#!/usr/bin/env python
# Code take from plugin IPTVPlayer: "https://gitlab.com/iptvplayer-for-e2/iptvplayer-for-e2/
# and modified for use with Plex Media Server by Twoure

from png import Reader as PNGReader

USER_AGENT = 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36'

def decode_hiddenUrl(x):
    s = list()
    try:
        for i in list(x):
            j = ord(i)
            if (j >= 33) and (j <= 126):
                s.append(chr(33 + ((j + 14) % 94)))
            else:
                s.append(chr(j))
    except:
        Log.Exception(u'* Cannot decode {}'.format(x))

    if s:
        return ''.join(s)
    return False

def OpenloadStreamFromURL(url, http_headers=None):
    if not http_headers:
        http_headers = {'User-Agnet': USER_AGENT, 'Referer': url}

    html = HTML.ElementFromURL(url, headers=http_headers, cacheTime=CACHE_1MINUTE)
    hiddenUrl = html.xpath('//span[@id="hiddenurl"]/text()')
    if hiddenUrl:
        hurl = decode_hiddenUrl(hiddenUrl[0])
        if hurl:
            return u'https://openload.co/stream/{0}?mime=true'.format(hurl)
        else:
            Log.Error(u'* Cannot directly decode hiddenUrl. Try to build videoUrl instead.')
    else:
        Log.Warn(u'* No hiddenUrl to decode. Try to build videoUrl instead.')

    imageData = html.xpath('//img[@id="linkimg"]/@src')
    imageData = String.Base64Decode(imageData[0].split('base64,')[-1]) if imageData else None
    if not imageData:
        return "error: cannot parse image data"

    x, y, pixel, meta = PNGReader(bytes=imageData).read()
    imageData = None
    imageStr = ''
    try:
        for item in pixel:
            for p in item:
                imageStr += chr(p)
    except Exception, e:
        Log.Error(str(d))
        return False

    # split image data
    imageTabs = []
    i = -1
    for idx in range(len(imageStr)):
        if imageStr[idx] == '\0':
            break
        if 0 == (idx % (12 * 20)):
            imageTabs.append([])
            i += 1
            j = -1
        if 0 == (idx % (20)):
            imageTabs[i].append([])
            j += 1
        imageTabs[i][j].append(imageStr[idx])

    # get signature data
    data = HTTP.Request('https://openload.co/assets/js/obfuscator/n.js', headers=http_headers, cacheTime=CACHE_1HOUR).content
    signStr = Regex(r'(?i)[\'\"]([^\"\']+?)[\'\"]').search(data)
    if not signStr:
        Log.Error('* cannot find signitures')
        return False

    signStr = signStr.group(1)

    # split signature data
    signTabs = []
    i = -1
    for idx in range(len(signStr)):
        if signStr[idx] == '\0':
            break
        if 0 == (idx % (11 * 26)):
            signTabs.append([])
            i += 1
            j = -1
        if 0 == (idx % (26)):
            signTabs[i].append([])
            j += 1
        signTabs[i][j].append(signStr[idx])

    # get link data
    linkData = {}
    for i in [2, 3, 5, 7]:
        linkData[i] = []
        tmp = ord('c')
        for j in range(len(signTabs[i])):
            for k  in range(len(signTabs[i][j])):
                if tmp > 122:
                    tmp = ord('b')
                if signTabs[i][j][k] == chr(int(Util.Floor(tmp))):
                    if len(linkData[i]) > j:
                        continue
                    tmp += 2.5;
                    if k < len(imageTabs[i][j]):
                        linkData[i].append(imageTabs[i][j][k])
    res = []
    for idx in linkData:
        res.append(''.join(linkData[idx]).replace(',', ''))

    res = res[3] + '~' + res[1] + '~' + res[2] + '~' + res[0]
    videoUrl = 'https://openload.co/stream/{0}?mime=true'.format(res)
    return videoUrl
